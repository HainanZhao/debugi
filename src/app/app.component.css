.app-container {
  display: flex;
  min-height: 100vh;
  background-color: #1a1a1a;
}

nav {
  width: 200px;
  flex-shrink: 0;
  background-color: #2d2d2d;
  padding: 20px;
  border-right: 1px solid #404040;
}

nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  display: flex;
  flex-direction: column;
}

nav ul li a {
  display: block;
  padding: 10px 15px;
  text-decoration: none;
  color: #e0e0e0;
  border-radius: 4px;
  margin-bottom: 5px;
  transition: background-color 0.2s;
}

nav ul li a.active {
  background-color: #0d7377;
  color: white;
}

nav ul li a:hover {
  background-color: #404040;
}

/* Styles for the main content area (where router-outlet is) */
/* We can apply styles directly to the host of router-outlet or wrap it if needed.
   For simplicity, let's assume router-outlet itself (or its direct parent if structure changes)
   will be the flex item. If router-outlet is directly inside .app-container,
   we need a way to target it. Angular's router-outlet doesn't directly accept class/style bindings
   in the same way as regular HTML elements for direct flex item styling.
   A common practice is to wrap <router-outlet> in a div if specific styling is needed for the container.
   However, if <router-outlet> is the direct child, flex-grow can be applied to it via a wrapping div
   or by targeting it specifically if the browser/Angular version supports it.
   Let's assume we add a class to a div wrapping router-outlet for clarity, e.g., 'content-area'.
   If not, these styles might need to be adjusted or applied to a more general selector.
*/

/* If router-outlet is wrapped in a div with class "content-area" */
.content-area {
  flex-grow: 1;
  padding: 20px;
  background-color: #1a1a1a;
  color: #e0e0e0;
}

/* Since router-outlet is a direct child of .app-container as per previous step,
   we might need to reconsider how to apply flex-grow.
   A simple way without adding another wrapper is to ensure .app-container's children
   are treated as flex items. The nav is already set to not grow/shrink.
   The router-outlet will naturally take up the remaining space if it's the only other child.
   However, for explicit control and padding, a wrapper div for router-outlet is better.
   Let's assume for now router-outlet itself will expand.
   If not, the HTML structure in app.component.html might need adjustment (add a wrapper div).
*/

/*
  If you don't want to add a wrapper around <router-outlet> in the HTML,
  and assuming <router-outlet> is a direct child of .app-container,
  you might rely on its default flex behavior or target it using :host / ng-deep (less ideal).
  A cleaner approach for styling the content area is to wrap <router-outlet>.

  Let's adjust app.component.html to include a wrapper for router-outlet for better styling.
  Then, the .content-area styles above will apply correctly.
*/
